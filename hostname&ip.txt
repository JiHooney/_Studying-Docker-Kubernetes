
			eth0		PublicIP
서버1	manager		172.31.4.67	3.35.136.85
서버2	worker1		172.31.7.172	3.38.116.2
서버3	worker2		172.31.15.144	3.34.135.182

-워커노드추가하기
docker swarm join \
--token SWMTKN-1-4il3welngidtmixsd4uw3be28moknc1m4bdjyc3hb41we8tb3y-5vnihejdxbl7xl8x4crr04k6c \
3.35.136.85:2377

-스웜모드
docker명령어의 제어 단위는 하나의 컨테이너,
docker swarm의 제어 단위는 서비스, 서비스는 같은 이미지에서 생성된 컨테이너의 집합,
서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령어를 동시에 수행한다.
예를들어 우분투 이미지로 서비스를 생성하고 컨테이너 수를 3개로 설정했다면 스웜 스케줄러는
서비스의 정의에 따라 컨테이너를 할당할 적합한 노드들을 선택한다. 반드시 각 노드에 하나씩
설정되는 것은 아니다.
아무튼 이처럼 함께 생성된 컨테이너를 레플리카(replica)라고 하며, 서비스에 설정된 레플리카의 수만큼
컨테이너가 스웜 클러스터 내에 존재해야 한다.
서비스는 롤링업데이트 기능도 제공. 서비스 내 컨테이너들의 이미지를 일괄적으로 업데이트해야 할 때
컨테이너들의 이미지를 순서대로 변경해 서비스 자체가 다운되는 시간 없이 업데이트를 진행한다.

-서비스 생성하기(매니저 노드에서 진행)
서비스 내의 컨테이너는 detached모드로 docker run -d ~ 옵션을 사용해 동작할 수 있는
이미지를 사용해야 한다.

docker service create \
ubuntu:14.04 \
/bin/sh -c "while true; do echo hello world; sleep 1; done"

-서비스 구동확인
docker service ls
docker service ps [서비스 이름]

-서비스 삭제
docker service rm youthful_sanderson

-nginx웹 서버 서비스 생성하기
docker service create --name myweb \
--replicas 2 \
-p 80:80 \
nginx

docker service ps myweb

두 대의 서버에 웹 서버 컨테이너가 만들어졌고 스웜 클러스터 내의 어떠한 노드로 접근해도
위 서비스의 웹 서버에 접근할 수 있다. worker2 노드의 IP주소 접근해보자.
(먼저 aws 보안그룹 인바운드 규칙에서 80포트 열고 아웃바운드는 모든 포트 열어놓기)

-nginx웹 서버 4대로 증설
docker service scale myweb=4
docker service ps myweb

-서비스의 종류 복제모드, 글로벌모드
복제모드: 레플리카셋의 수를 정의해 그만큼의 컨테이너를 생성
글로벌모드: 스웜클럴스터 내에서 사용할 수 있는 모든 노드에 컨테이너를 반드시 하나씩 생성
따라서 글로벌모드에서는 레플리카 셋의 수를 지정하지 않는다.

-글로벌 모드 서비스 생성
docker service create --name global_web \
--mode global \
nginx

docker service ls
docker service ps global_web

-스웜모드의 서비스 장애 복구
서비스 내의 컨테이너 하나 삭제하면 스웜이 알아서 새로운 노드에 해당 컨테이너를 자동으로
생성해준다.

-서비스 롤링 업데이트
nginx웹서버 낮은 버전으로 서비스를 만들고 업데이트를 해본다.

docker service create --name myweb2 \
--replicas 3 \
nginx:1.10

docker service ls
docker service ps myweb2

docker service update \
--image nginx:1.11 \
myweb2

docker service ps myweb2

\_가 붙어있는 것이 업데이트 되기 전 삭제된 컨테이너이고,
\_가 붙어있지 않은 것이 업데이트 된 컨테이너이다.

-서비스 생성 시 롤링 업데이트에 관한 설정하기
docker service create \
--replicas 4 \
--name myweb3 \
--update-delay 10s \
--update-parallelism 2 \
nginx:1.10

-해당 서비스의 설정된 롤링업데이트 설정 출력하기
docker service inspect --pretty myweb3

-롤링 업데이트 이전으로 되돌리기
docker service rollback myweb3

-서비스 컨테이너에 설정 정보 전달하기: config, secret
애플리케이션을 외부에 서비스하게 하려면 내 환경에 맞춘 설정파일이나 값들이 컨테이너 내부에
미리 준비돼 있어야 한다. 지금까지는 호스트에 위치한 설정파일이나 값을 볼륨으로써 컨테이너에 
공유했다. 아래와 같이 사설 레지스트리를 생성할 때 설정파일을 전달하거나
docker run -d --name yml_registry \
-p 5002:5000 \
--restart=always \
-v $(pwd)/config.yml:/etc/docker/registry/config.yml \
registry:2.6

혹은 컨테이너 내부의 설정값을 유동적으로 설정하기 위해 -e옵션을 통한 환경 변수도 사용할 수 있다.
docker run -d \
--name wordpressdb_hostvolume \
-e MYSQL_ROOT_PASSWORD=password \
-e MYSQL_DATABASE=wordpress \
-v /home/wordpress_db:/var/lib/mysql \
mysql:5.7

그러나 스웜 모드와 같은 서버 클러스터에서 파일 공유를 위해 설정 파일을 호스트마다 마련해두는
것은 매우 비효율적이다.  그뿐만 아니라 비밀번호와 같이 민감한 정보를 환경 변수로 설정하는 것은
보안상으로 아주 위험하다. 이를 위해 스웜모드에서는 secret과 config라는 기능을 제공한다.
secret은 SSH키, 인증서 키와 같이 민감한 데이터를 전송하기 위해서,
config는 nginx나 레지스트리 설정 파일과 같이 암호화할 필요가 없는 설정값들에 대해 쓰일 수 있다.

그러나 secret과 config는 스웜모드에서만 사용될 수 있는 기능이다. docker run에서는 사용할 수 없다.

-secret사용하기
파일에 저장된 비번을 사용할 수 있지만 아래와 같이 echo명령어를 통해 비번을 입력할 수 있다.
echo 1q2w3e4r | docker secret create my_mysql_password -

docker secret ls

docker secret inspect my_mysql_password

생성된 secret을 조회해도 실제 값을 확인할 수 없다. secret값은 매니저 노드 간에 암호화된 상태로
저장된다. 또한 secret파일은 컨테이너에 배포된 뒤에도 파일 시스템이 아닌 메모리에 저장되기 때문에
서비스 컨테이너가 삭제될 경우 같이 삭제되는 일종의 휘발성을 띠게 된다.

-생성한 secret을 통해 mysql 컨테이너 생성
docker service create \
--name mysql \
--replicas 1 \
--secret source=my_mysql_password,target=mysql_root_password \
--secret source=my_mysql_password,target=mysql_password \
-e MYSQL_ROOT_PASSWORD_FILE="/run/secrets/mysql_root_password" \
-e MYSQL_PASSWORD_FILE="/run/secrets/mysql_password" \
-e MYSQL_DATABASE="wordpress" \
mysql:5.7

--secret옵션을 통해 컨테이너로 공유된 값은 기본적으로 컨테이너 내부의 /run/secrets/ 디렉터리에
마운트됩니다. 

도커 안에서 /run/secrets 디렉토리에 비번 파일있는지 확인하기
docker ps
docker exec mysql.1.wc7kgdws5vngvha7bl4cr98n8 ls /run/secrets
docker exec mysql.1.wc7kgdws5vngvha7bl4cr98n8 cat /run/secrets/mysql_password


-config 사용하기
사설 레지스트리의 설정파일을 registry-config라는 이름의 config로 저장한다.
먼저 yml파일이란 xml이나 json처럼 어려운 형식말고 읽고 쓰기 쉽도록 만들어진 데이터 형식파일이다.

vi config.yml

version: 0.1
log:
  level: info
storage:
  filesystem:
    rootdirectory: /registry_data
  delete:
    enabled: true
http:
  addr: 0.0.0.0:5000


<!--
yml파일 만들기
docker run -d -p 5001:5000 \
--name registry_delete_enabled \
--restart=always \
-e REGISTRY_STORAGE_DELETE_ENABLED=true \
-e REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/var/lib/mydocker \

docker exec registry_delete_enabled cat /etc/docker/registry/config.yml
-->


docker config create registry-config config.yml
docker config inspect registry-config

Data라는 항목을 base64로 인코딩한 뒤 저장하고 디코딩하면 원래의 값을 확인할 수 있다.
echo [Data] | base64 -d
echo dmVyc2lvbjogMC4xCmxvZzoKICBsZXZlbDogaW5mbwpzdG9yYWdlOgogIGZpbGVzeXN0ZW06CiAgICByb290ZGlyZWN0b3J5OiAvcmVnaXN0cnlfZGF0YQogIGRlbGV0ZToKICAgIGVuYWJsZWQ6IHRydWUKaHR0cDoKICBhZGRyOiAwLjAuMC4wOjUwMDAK | base64 -d

-config로 사설 레지스트리 생성하기
docker service create \
--name yml_registry \
-p 5000:5000 \
--config source=registry-config,target=/etc/docker/registry/config.yml \
registry:2.6

secret과 config의 값은 수정할 수 없지만, 서비스 컨테이너가 새로운 값을 사용해야 한다면
docker service update 명령어의 --config-rm, --config-add, --secret-rm, --secret-add옵션을 사용해
서비스가 사용하는 secret이나 config를 추가하고 삭제할 수 있다.
이를 활용하면 이미지를 다시 빌드할 필요 없이도 여러 설정값의 애플리케이션을 쉽게
사용할 수 있다.
