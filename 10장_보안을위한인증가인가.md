ServiceAccount와 RBAC

```java
클라우드 플랫폼은 보통 수많은 사용자와 애플리케이션이 동시에 사용된다. 
쿠버네티스도 여러 명의 개발자가 쿠버네티스에 접근할 수도 있고, 각 개발자가 kubectl과 같은 명령어를 통해
애플리케이션을 동시에 배포할 수도 있다.

이때 중요한 것은 바로 보안이다.
쿠버네티스에서 가장 자주 사용되는 것이 **RBAC(Role Based Access Control) 기반으로 하는 서비스 어카운트(Service Account)**
라는 기능이다.
**서비스 어카운트는 사용자 또는 애플리케이션 하나에 해당**하며, **RBAC라는 기능을 통해 특정 명령을 실행할 수 있는 권한을 
서비스 어카운트에 부여한다.**
권한을 부여받은 서비스 어카운트는 해당 권한에 해당하는 기능만 사용할 수 있게 된다.

간단히 말해서 리눅스에서 root 유저와 일반 유저를 나누는 기능이라고 생각하면 된다.

여태까지 사용했던 kubectl 명령어는 사실 최상위에 해당하는 명령어이다.
쿠버네티스의 api에 접근하는 애플리케이션을 운영 환경에 배포하거나,
여러 명의 사용자가 동시에 쿠버네티스를 사용해야 한다면 최상위 권한을 사용하지 않는 것이 좋다.
```

# 10.1 쿠버네티스의 권한 인증 과정

```java
쿠버네티스는 kube-apiserver, kube-controller, kube-scheduler, etcd 등과 같은 컴포너는들로 구성돼 있다.
이 중 가장 많이 접하게 되는 컴포넌트는 kube-apiserver이다.

===* 참고
쿠버네티스 컴포넌트들 확인하기
> kubectl get pods -n kube-system
kube-system이란 네임스페이스에서 실행되고 있는 컴포넌트들이다.
===

kubectl 명령어를 사용하면 쿠버네티스 내부에서는 아래와 같은 일이 일어난다.
```

그림10.2

```java
가장 먼저 kubectl 명령어는 쿠버네티스 api 서버의 http 핸들러에 요청을 전송한다.
api서버는 해당 클라이언트가 쿠버네티스의 사용자가 맞는지(Authentication: 인증), 
해당 기능을 실행할 권한이 있는지(Authorization: 인가)를 확인한다.
인증과 인가에는 서비스 어카운트 외에도 서드파티 인증(Open ID Connect: OAuth), 인증서 등과 같이 다양한 방법이 사용될 수 있다.
그 뒤에는 어드미션 컨트롤러(Admission Controlle)라는 별도의 단계를 거친 뒤 비로소 요청받은 기능을 수행한다.

쿠버네티스를 설치할 때 설치 도구가 자동으로 kubectl 이 관리자 권한을 갖도록 설정해둔다.
이러한 설정은 ~/.kube/config 라는 파일에서 확인할 수 있다.

kubectl을 사용할 때는 기본적으로 ~/.kube/config라는 파일에 저장된 설정을 읽어 들여 쿠버네티스 클러스터를 제어한다.
이 파일에 저장된 내용 중에서 users 라는 항목에는 인증을 위한 데이터가 설정돼 있다.

client-certifiacate-data와 client-key-data에 설정된 데이터는 base64로 인코딩된 인증서(공개키와 비밀키)인데,
이 키 쌍은 쿠버네티스에서 최고 권한(cluster-admin)을 갖는다.

기본적으로 설정된 ~/.kube/config 파일에서는 인증서 키 쌍을 사용해 api서버에 인증하지만,
이 인증 방법은 비교적 절차가 복잡하고 관리하기가 어렵기 때문에 자주 사용하는 방법은 아니다.

```

# 10.2 서비스 아카운트와 롤(Role), 클러스터 롤(Cluster Role)

```java
서비스 어카운트는 체계적으로 권한을 관리하기 위한 쿠버네티스 오브젝트이다. 

#서비스 어카운트 목록 확인
> kubectl get sa
> kubectl get serviceaccount

#서비스 어카운트 생성 및 삭제
> kubectl create sa alicek106
> kubectl delete sa alicek106

이번에는 방금 생성한 alicek106이라는 이름의 서비스 어카운트를 이용해
kubectl 명령어를 사용해본다.
--as옵션을 사용하면 임시로 특정 서비스 어카운트를 사용할 수 있다.

> kubectl create sa alicek106
> kubectl get services

> kuebctl get services --as system:serviceaccount:default:alicek106

--as 옵션에 사용된 system:serviceaccount는 인증을 위해 서비스 어카운트를 사용한다는 것을 나타내며,
default:alicek106은 default 네임스페이스의 alicek106 서비스 어카운트를 의미한다.

방금 생성한 alicek106 서비스 어카운트로 서비스의 목록을 조회했더니 api 서버로부터 에러가 반환됐다.
이 서비스 어카운트는 default 네임스페이스에서 서비스 목록을 조회할 수 있는 권한이 아직 
부여되지 않았기 때문이다.

따라서 서비스 어카운트에 적절한 권한을 부여해야만 쿠버네티스의 기능을 제대로 사용할 수 있다.

쿠버네티스에서 권한을 부여하는 방법은 크게 두 가지가 있다.
롤(Role)과 클러스터 롤(Cluster Role)을 이용해 권한을 설정하는 것이다.
```

그림10.3

```java
롤과 클러스터 롤은 부여할 권한이 무엇인지를 나타내는 쿠버네티스 오브젝트이다. 
예를 들어 '디플로이먼트를 생성할 수 있다.'라는 것도 하나의 롤이 될 수 있고,
'서비스의 목록을 조회한다'라는 것도 롤이 될 수 있다.

**단, 롤은 네임스페이스에 속하는 오브젝트이므로 디플로이먼트나 서비스처럼 네임스페이스에 속하는
오브젝트들에 대한 권한을 정의할 때 쓰인다.**

**롤과 비슷한 클러스터 롤이 있는데, 클러스터 롤은 말 그대로 클러스터 단위의 권한을 정의할 때 사용한다.**
예를 들어 '퍼시스턴트 볼륨의 목록을 조회할 수 있다.'라는 권한은 클러스터 롤로 정의할 수 있다.
또한 네임스페이스에 속하지 않는 오브젝트뿐만 아니라 클러스터 전반에 걸친 기능을 사용하기 위해서도
클러스터 롤을 정의할 수 있으며, 여러 네임 스페이스에서 반복적으로 사용하는 권한을 클러스터 롤로 만들어 재사용하는 것도 가능하다.

롤은 네임스페이스에 속하지만, 클러스터 롤은 네임스페이스에 속하지 않는 전역적인 쿠버네티스 오브젝트이다.
> kubectl get role

> kubectl get clusterrole

롤을 사용해본다.
> mkdir chapter10
> vi service-reader-role.yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: service-reader
rules:
- apiGroups: [""]                 # 1. 대상이 될 오브젝트의 API 그룹
  resources: ["services"]          # 2. 대상이 될 오브젝트의 이름
  verbs: ["get", "list"]             # 3. 어떠한 동작을 허용할 것인지 명시

metadata항목의 namespace는 롤이 생성될 네임스페이스를, name은 롤의 이름을 설정했다.
rules 항목들은 자세히 살펴본다.

-apiGroups: 어떠한 api 그룹에 속하는 오브젝트에 대해 권한을 지정할지 설정한다.
api 그룹은 쿠버네티스의 오브젝트가 가지는 목적에 따라 분류되는 일종의 카테고리이다. 
위 예시에서는 ""로 설정했는데, 이는 포드, 서비스 등이 포함된 코어 API 그룹을 의미한다.
kubectl api-resources명령어를 사용하면 특정 쿠버네티스 오브젝트가 어떤 API 그룹에
속하는지 확인할 수 있다.

> kubectl api-resources

-resources: 어떠한 쿠버네티스 오브젝트에 대해 권한을 정의할 것인지 입력한다.
위 예시에서는 서비스를 다룰 수 있는 권한을 정의할 것이기 때문에 ["services"]와 같이 설정했다.
resources 항목 또한 kubectl api-resources에 출력되는 오브젝트의 이름을 적절히 사용하면 된다.

-verbs: 이 롤을 부여받은 대상이 resources에 지정된 오브젝트들에 대해 어떤 동작을 수행할 수 있는지 정의한다.
위 예시에서는 get과 list 동작을 명시했으므로 kubectl get services 명령어로 개별 서비스의 정보를 가져오거나
모든 서비스 목록을 확인할 수 있도록 권한이 부여된다.

따라서 이 yaml파일에 정의된 apiGroup과 resources, verbs를 종합하면 
"코어 API 그룹("")에 속하는 서비스 리소스에 대해 get과 list를 실행할 수 있다" 라고 해석할 수 있다.

이 yaml 파일을 이용해서 롤을 생성한다.
> kubectl apply -f service-reader-role.yaml

> kubectl get roles

그렇지만 롤은 특정 기능에 대한 권한만을 정의하는 오브젝트이기 때문에 롤을 생성하는 것만으로는
서비스 어카운트나 사용자에게 권한이 부여되지 않는다.
이 롤을 특정 대상에게 부여하려면 롤 바인딩(RoleBinding)이라는 오브젝트를 통해 특정 대상과 롤을 연결해야 한다.

예를 들어 서비스 어카운트에 롤에 정의된 권한을 부여하려면 아래와 같은 롤 바인딩을 생성해야 한다.

> vi rolebinding-service-reader.yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: service-reader-rolebinding
  namespace: default
subjects:
- kind: ServiceAccount
  name: alicek106
  namespace: default
roleRef:
  kind: Role
  name: service-reader
  apiGroup: rbac.authorization.k8s.io

롤 바인딩에서는 어떠한 대상을 어떠한 롤에 연결할 것인지 정의한다.
위 예시에서는 subjects 항목에 alicek106이라는 이름의 서비스 어카운트를,
roleRef 항목에 service-reader 롤을 지정했다.
따라서 alicek106 서비스 어카운트는 service-reader롤에 정의된 권한을 사용할 수 있게 된다.

롤 바인딩을 생성한 뒤 다시 alicek106 서비스 어카운트로 명령어를 샐행해본다.
> kubectl apply -f rolebinding-service-reader.yaml

> kubectl get services --as system:serviceaccount:default:alicek106

서비스의 목록을 확인할 수 있는 권한을 부여받았기 때문에 정상적으로 kubectl get services 명령어를 사용할 수 있다.
하지만 다른 기능들은 사용할 수 없다.

롤 바인딩과 롤, 서비스 어카운트는 모두 1:1 관계가 아니라는 점에 유의해야 한다.
하나의 롤은 여러 개의 롤 바인딩에 의해 참조될 수도 있고,
하나의 서비스 어카운트는 여러 개의 롤 바인딩에 의해 권한을 부여받을 수도 있다.

**즉, 롤은 권한을 부여하기 위한 일종의 템플릿과 같은 역할이고,
롤 바인딩은 롤과 서비스 어카운트를 연결하기 위한 중간 다리 역할을 하는 셈이다.**
```

- 롤 vs 클러스터 롤

```java
롤과 롤 바인딩은 네임스페이스에 한정되는 오브젝트이다. 
따라서 롤은 포드, 서비스, 디플로이먼트 등과 같이 네임스페이스에 한정된 오브젝트에 대한
권한을 정의하기 위해 사용할 수 있다.
그렇지만 지금까지 다뤘던 오브젝트 중에는 노드(nodes), 퍼시스턴트 볼륨 등과 같이
네임스페이스에 종속되지 않는 오브젝트도 존재한다.

클러스터 수준의 오브젝트들에 대한 접근 권한은 서비스 어카운트에 기본적으로 설정돼 있지 않다.
이전에 생성해 뒀던 alicek106 서비스 어카운트로 노드의 목록을 출력해보면 cluster scope의
리소스를 사용할 수 없다는 에러가 뜬다.
또한 네임스페이스의 리소스를 출력하는 명령어 또한 에러를 출력한다.

이런 경우에는 롤 대신 클러스터 롤을 사용할 수 있다.
**클러스터 롤은 클러스터 단위의 리소스에 대한 권한을 정의하기 위해 사용한다.**
노드의 목록을 출력하기 위한 클러스터 롤을 생성해본다.

> vi nodes-reader-clusterrole.yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  namespace: default
  name: nodes-reader
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list"]

이전에 role과 다르지 않다. 
kind가 달라진 것 밖에 없다.

#클러스터 롤 생성
> kubectl apply -f nodes-reader-clusterrole.yaml

> kubectl describe clusterrole nodes-reader

클러스터 롤을 특정 대상에게 연결하려면 **클러스터 롤 바인딩**이라고 하는 쿠버네티스 오브젝트를 사용해야 한다.
클러스터 롤 바인딩은 클러스터 롤과 특정 대상을 연결하는 중간 매개체 역할을 한다.

#클러스터 롤 바인딩 생성
> vi clusterrolebinding-nodes-reader.yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nodes-reader-clusterrolebinding
  namespace: default
subjects:
- kind: ServiceAccount
  name: alicek106
  namespace: default
roleRef:
  kind: ClusterRole
  name: nodes-reader
  apiGroup: rbac.authorization.k8s.io

> kubectl apply -f clusterrolebinding-nodes-reader.yaml

nodes-reader라는 이름의 클러스터 롤이 서비스 어카운트와 연결됐으므로 
이제 노드의 목록을 출력할 수 있다.
> kubectl get nodes --as system:serviceaccount:default:alicek106

```

- 여러 개의 클러스터 롤을 조합해서 사용하기

```java
자주 사용되는 클러스터 롤이 있다면 다른 클러스터 롤에 포함시켜 재사용할 수 있는데,
이를 클러스터 롤 애그리게이션(aggregation)이라고 한다.
이를 사용하기 위해 클러스터 롤을 정의해본다.

> vi clusterrole-aggregation.yaml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: grand-parent-clusterrole
  labels:
    rbac.authorization.k8s.io/aggregate-to-parent-clusterrole: "true"
rules: []
  #- apiGroups: [""]
  #  resources: ["nodes"]
  #  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.authorization.k8s.io/aggregate-to-parent-clusterrole: "true"
metadata:
  name: parent-clusterrole
  labels:
    rbac.authorization.k8s.io/aggregate-to-child-clusterrole: "true"
rules: []
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: child-clusterrole
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.authorization.k8s.io/aggregate-to-child-clusterrole: "true"
rules: [] # 어떠한 권한도 정의하지 않았습니다.
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: node-reader-test
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: parent-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: node-reader-test
  namespace: default
roleRef:
  kind: ClusterRole
  name: child-clusterrole
  apiGroup: rbac.authorization.k8s.io

이번에는 aggregationRole.clusterRoleSelectors라는 항목을 사용했다.
클러스터 롤에 포함시키고자 하는 다른 클러스터 롤을 matchLabels의 라벨 셀렉터로 선택하면
하위 클러스터 롤에 포함돼 있는 권한을 그대로 부여받을 수 있다.
위 예시에서 child-clusttole 에 아무런 권한도 부여하지 않았지만 parent-clusterrole의 권한을
그래도 물려받았으므로 child-clusterrole에서 nodes에 대한 get/list 권한을 갖게 된다.

> kubectl apply -f clusterrole-aggregation.yaml

> kubectl get no --as system:serivceaccount:default:node-reader-test

클러스터 롤 애그리게이션을 사용하면 여러 개의 클러스터 롤 권한을 하나의 클러스터 롤에 합쳐서
사용할 수도 있으며, 여러 단계의 클러스터 롤 권한 상속 구조를 만들 수도 있다.
```

# 10.3 쿠버네티스 API 서버에 접근

- 10.3.1 서비스 어카운트의 시크릿을 이용해 쿠버네티스 API 서버에 접근

```java

```

- 10.3.2 클러스터 내부에서 kubernetes 서비스를 통해 API 서버에 접근

```java

```

- 10.3.3 쿠버네티스 SDK를 이용해 포드 내부에서 API 서버에 접근

```java

```

# 10.4 서비스 어카운트에 이미지 레지스트리 접근을 위한 시크릿 설정

```java

```

# 10.5 kubeconfig 파일에 서비스 어카운트 인증 정보 설정

```java

```

# 10.6 유저(User)와 그룹(Group)의 개념

```java

```

# 10.7 x509 인증서를 이용한 사용자 인증

```java

```
